<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake Chase by Hojat</title>
<style>
  body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: #1a1a2e;
      font-family: 'Courier New', monospace;
      color: #eee;
      overflow-x: hidden;
      overflow-y: auto; /* changed from hidden */
      touch-action: none;
  }
  h1 { margin: 10px 0; font-size: 24px; color: #00ff88; }
  #stats {
      display: none;
      gap: 30px;
      font-size: 18px;
      margin: 10px 0;
  }
  #scoreBoard span { color: #00ff88; font-weight: bold; }
  #hearts { color: #ff4466; letter-spacing: 5px; }
  canvas {
      border: 3px solid #00ff88;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
      background: #0f0f1a;
      display: block;
      width: 100%;
      max-width: 600px;
      height: auto;
      touch-action: none;
  }
  #menuScreen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 90%;
      max-width: 600px;
      height: auto;
      padding: 30px 0;
      background: #0f0f1a;
      border: 3px solid #00ff88;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
  }
  #menuScreen h2 { font-size: 32px; color: #00ff88; margin-bottom: 30px; }
  .difficulty-btn {
      padding: 15px 40px;
      margin: 10px;
      font-size: 20px;
      font-family: 'Courier New', monospace;
      border: 2px solid #00ff88;
      background: transparent;
      color: #00ff88;
      cursor: pointer;
      transition: all 0.2s;
      width: 220px;
  }
  .difficulty-btn:hover { background: #00ff88; color: #0f0f1a; }
  .difficulty-btn.easy { border-color: #44ff88; color: #44ff88; }
  .difficulty-btn.easy:hover { background: #44ff88; color: #0f0f1a; }
  .difficulty-btn.medium { border-color: #ffaa00; color: #ffaa00; }
  .difficulty-btn.medium:hover { background: #ffaa00; color: #0f0f1a; }
  .difficulty-btn.hard { border-color: #ff4444; color: #ff4444; }
  .difficulty-btn.hard:hover { background: #ff4444; color: #0f0f1a; }
  #instructions {
      margin-top: 15px;
      font-size: 14px;
      color: #888;
      text-align: center;
      padding: 0 20px;
  }
  #mobileControls {
      position: static; /* changed from fixed */
      width: 180px;
      margin: 20px auto; /* centering and spacing */
      z-index: 10;
      pointer-events: auto;
      user-select: none;
      display: none;
  }
  .control-dpad {
      position: relative;
      width: 180px;
      height: 180px;
  }
  .control-btn {
      position: absolute;
      width: 70px;
      height: 70px;
      font-size: 40px;
      background: rgba(0, 255, 136, 0.12);
      border: 2px solid #00ff88;
      color: #00ff88;
      border-radius: 16px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
  }
  .control-btn:active { background: rgba(0, 255, 136, 0.35); }
  #up    { top: 0;    left: 55px; }
  #down  { bottom: 0; left: 55px; }
  #left  { left: 0;   top: 55px; }
  #right { right: 0;  top: 55px; }
  @media (max-width: 768px), (pointer: coarse) {
      #mobileControls { display: block; }
      h1 { font-size: 22px; margin: 8px 0; }
      #stats { font-size: 16px; gap: 20px; }
      canvas { border-width: 2px; }
  }
</style>
</head>
<body>
<h1>üêç Snake Chase</h1>
<div id="stats">
    <div id="scoreBoard">Score: <span id="score">0</span></div>
    <div id="hearts">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
</div>
<div id="menuScreen">
    <h2>Select Difficulty</h2>
    <button class="difficulty-btn easy" onclick="startGame(200)">üê£ Easy</button>
    <button class="difficulty-btn medium" onclick="startGame(100)">üî• Medium</button>
    <button class="difficulty-btn hard" onclick="startGame(66)">üíÄ Hard</button>
</div>
<canvas id="game" width="600" height="400" style="display: none;"></canvas>
<div id="instructions" style="display: none;">Arrow Keys / WASD to move | Space to restart</div>
<div id="mobileControls">
    <div class="control-dpad">
        <button id="up"    class="control-btn">‚Üë</button>
        <button id="down"  class="control-btn">‚Üì</button>
        <button id="left"  class="control-btn">‚Üê</button>
        <button id="right" class="control-btn">‚Üí</button>
    </div>
</div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const heartsEl = document.getElementById('hearts');
const statsEl = document.getElementById('stats');
const menuScreen = document.getElementById('menuScreen');
const instructionsEl = document.getElementById('instructions');

const GRID_SIZE = 20;
const TILE_COUNT_X = canvas.width / GRID_SIZE;
const TILE_COUNT_Y = canvas.height / GRID_SIZE;

let snake = [];
let snakeHistory = [];
let target = { x: 0, y: 0 };
let dx = 0, dy = 0;
let nextDx = 0, nextDy = 0;
let score = 0;
let hearts = 3;
let savedLength = 3;
let gameOver = false;
let isReversing = false;
let isCountingDown = false;
let gameLoop = null;
let gameSpeed = 100;

function startGame(speed) {
    gameSpeed = speed;
    savedLength = 3;
    menuScreen.style.display = 'none';
    canvas.style.display = 'block';
    statsEl.style.display = 'flex';
    instructionsEl.style.display = 'block';
    initGame();
}

function initGame() {
    snake = [];
    for (let i = 0; i < savedLength; i++) {
        snake.push({ x: 5 - i, y: 5 });
    }
    snakeHistory = snake.map(s => ({ ...s }));
    dx = 1; dy = 0;
    nextDx = 1; nextDy = 0;
    score = 0;
    hearts = 3;
    gameOver = false;
    isReversing = false;
    isCountingDown = false;
    scoreEl.textContent = score;
    updateHeartsDisplay();
    spawnTarget();
    if (gameLoop) clearInterval(gameLoop);
    gameLoop = setInterval(update, gameSpeed);
}

function updateHeartsDisplay() {
    let str = '';
    for (let i = 0; i < hearts; i++) str += '‚ù§Ô∏è';
    for (let i = hearts; i < 3; i++) str += 'üñ§';
    heartsEl.textContent = str;
}

function spawnTarget() {
    target = {
        x: Math.floor(Math.random() * TILE_COUNT_X),
        y: Math.floor(Math.random() * TILE_COUNT_Y)
    };
    if (snake.some(s => s.x === target.x && s.y === target.y)) spawnTarget();
}

function handleFailure() {
    if (hearts > 0) {
        hearts--;
        updateHeartsDisplay();
        startReversingAnimation();
    } else {
        gameOver = true;
        draw();
    }
}

function startReversingAnimation() {
    isReversing = true;
    let toRemove = 0; // unchanged (always 0 ‚Äì but keeps original logic)
    let idx = snakeHistory.length - 1;
    const rev = setInterval(() => {
        if (toRemove > 0 && idx >= 3) {
            snake.pop();
            toRemove--;
            idx--;
            draw();
        } else {
            clearInterval(rev);
            savedLength = snake.length;
            snakeHistory = snake.map(s => ({ ...s }));
            startCountdown();
        }
    }, 80);
}

function startCountdown() {
    isCountingDown = true;
    let count = 3;
    const cd = setInterval(() => {
        drawCountdown(count);
        count--;
        if (count < 0) {
            clearInterval(cd);
            isCountingDown = false;
            isReversing = false;
            dx = nextDx = 0;
            dy = nextDy = 0;
        }
    }, 800);
}

function drawCountdown(n) {
    draw();
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.font = 'bold 100px Courier New';
    ctx.fillStyle = n > 0 ? '#ffff00' : '#00ff88';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(n > 0 ? n : 'GO!', canvas.width/2, canvas.height/2);
}

function update() {
    if (gameOver || isReversing || isCountingDown) return;
    dx = nextDx;
    dy = nextDy;
    if (dx === 0 && dy === 0) return;
    const head = { x: snake[0].x + dx, y: snake[0].y + dy };
    if (head.x < 0 || head.x >= TILE_COUNT_X ||
        head.y < 0 || head.y >= TILE_COUNT_Y ||
        snake.some(s => s.x === head.x && s.y === head.y)) {
        handleFailure();
        return;
    }
    snakeHistory.push({ ...head });
    if (snakeHistory.length > 1000) snakeHistory = snakeHistory.slice(-500);
    snake.unshift(head);
    if (head.x === target.x && head.y === target.y) {
        score++;
        scoreEl.textContent = score;
        spawnTarget();
    } else {
        snake.pop();
    }
    draw();
}

function draw() {
    ctx.fillStyle = '#0f0f1a';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    if (gameOver) {
        ctx.fillStyle = '#ff4444';
        ctx.font = '50px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 40);
        ctx.font = '24px Courier New';
        ctx.fillStyle = '#fff';
        ctx.fillText(`Score: ${score}`, canvas.width/2, canvas.height/2 + 10);
        ctx.fillText('Space to restart', canvas.width/2, canvas.height/2 + 50);
        return;
    }
    const p = Math.sin(Date.now()/150)*2;
    ctx.fillStyle = '#ff4444';
    ctx.fillRect(target.x*GRID_SIZE+2-p/2, target.y*GRID_SIZE+2-p/2,
                  GRID_SIZE-4+p, GRID_SIZE-4+p);
    snake.forEach((s, i) => {
        ctx.fillStyle = i===0 ? '#00ff88' : '#00cc6a';
        ctx.fillRect(s.x*GRID_SIZE+1, s.y*GRID_SIZE+1, GRID_SIZE-2, GRID_SIZE-2);
        if (i===0) {
            ctx.fillStyle = '#000';
            const es=4;
            if (dx===1 || (dx===0&&dy===0)) {
                ctx.fillRect(s.x*GRID_SIZE+12, s.y*GRID_SIZE+5, es, es);
                ctx.fillRect(s.x*GRID_SIZE+12, s.y*GRID_SIZE+11, es, es);
            } else if (dx===-1) {
                ctx.fillRect(s.x*GRID_SIZE+4, s.y*GRID_SIZE+5, es, es);
                ctx.fillRect(s.x*GRID_SIZE+4, s.y*GRID_SIZE+11, es, es);
            } else if (dy===-1) {
                ctx.fillRect(s.x*GRID_SIZE+5, s.y*GRID_SIZE+4, es, es);
                ctx.fillRect(s.x*GRID_SIZE+11, s.y*GRID_SIZE+4, es, es);
            } else if (dy===1) {
                ctx.fillRect(s.x*GRID_SIZE+5, s.y*GRID_SIZE+12, es, es);
                ctx.fillRect(s.x*GRID_SIZE+11, s.y*GRID_SIZE+12, es, es);
            }
        }
    });
}

document.addEventListener('keydown', e => {
    if (gameOver && e.code === 'Space') {
        savedLength = 3;
        initGame();
        return;
    }
    if (isReversing || isCountingDown) return;
    switch (e.key.toLowerCase()) {
        case 'arrowup': case 'w':
            if (dy !== 1)  { nextDx=0; nextDy=-1; }
            break;
        case 'arrowdown': case 's':
            if (dy !== -1) { nextDx=0; nextDy=1; }
            break;
        case 'arrowleft': case 'a':
            if (dx !== 1)  { nextDx=-1; nextDy=0; }
            break;
        case 'arrowright': case 'd':
            if (dx !== -1) { nextDx=1; nextDy=0; }
            break;
    }
    if (dx===0 && dy===0) { dx=nextDx; dy=nextDy; }
});

const dirs = {
    up:    {dx:0, dy:-1},
    down:  {dx:0, dy:1},
    left:  {dx:-1,dy:0},
    right: {dx:1, dy:0}
};

Object.keys(dirs).forEach(key => {
    const btn = document.getElementById(key);
    const dir = dirs[key];
    const handler = e => {
        e.preventDefault();
        if (gameOver || isReversing || isCountingDown) return;
        if (dir.dy !== -dy || dir.dx !== -dx) {
            nextDx = dir.dx;
            nextDy = dir.dy;
        }
    };
    btn.addEventListener('touchstart', handler);
    btn.addEventListener('mousedown', handler);
});
</script>
</body>
</html>
